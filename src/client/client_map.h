#ifndef _CLIENT_MAP_H_
#define _CLIENT_MAP_H_

#include <stdbool.h>
#include <pthread.h>
#include <dragonstd/queue.h>
#include "map.h"
#include "client/object.h"

typedef enum
{
	MBS_RECIEVING, // currently deserializing
	MBS_FRESH,     // first deserialisation finished, not processed by sync thread yet
	MBS_READY,     // ready to use and processed by sync thread
} MapBlockState;

typedef struct
{
	MapBlockState state; // keep track of the deserialisation and sync processing state
	bool queue;          // whether the block is in meshgen queue
	u64 last_synced;     // keep track of when a block was synced the last time (used to detect when a block got out of and then back into range)
	Object *obj;         // mesh object, generated by blockmesh file
	bool all_air;        // no thoughts brain empty
} MapBlockExtraData;

extern struct ClientMap
{
	Map *map;                   // map object
	Queue *queue;               // MapBlock * queue (thread safe)
	atomic_bool cancel;         // used to notify meshgen and sync thread about quit
	pthread_t *meshgen_threads; // consumer threads for meshgen queue
	pthread_t sync_thread;      // this thread requests new / changed blocks from server
	u32 simulation_distance;    // simulation distance sent by server
	size_t blocks_count;        // cached number of facecache positions to process every sync step (matches simulation distance)
} client_map;

void client_map_init();                                           // ClientMap singleton constructor
void client_map_deinit();                                         // ClientMap singleton destructor
void client_map_set_simulation_distance(u32 simulation_distance); // update simulation distance
void client_map_start();                                          // start meshgen and sync threads
void client_map_stop();                                           // stop meshgen and sync threads
void client_map_block_received(MapBlock *block);                  // called when a block was actually recieved from server
void client_map_schedule_update_block_mesh(MapBlock *block);      // enqueue block to mesh update queue

#endif
